你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/house-robber
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
---

这道题。。。ummmmm我很不懂名为“动态规划”的东西，感觉它很高深？但确实也。。。
看了好久，一开始就在想，是不是分奇偶来求就行了，要相邻嘛，那奇数和偶数房子间肯定不连起来。
这符合一部分情况，但不是所有。
这种题。。。似乎是要找**状态转移方程**？就是看它是怎么变的，毕竟这是一个递归问题
以[1, 2, 3, 1]举例
有这么几种情况？
1. 只有一个元素[A],则是它最大了
2. 有两个元素[A, B],那么就是找Math.max(A, B)，即A、B间的较大者。
3. 若有三个元素[A, B, C],要么就是A+C，要么就是B，即Math.max(A + C, B)。
4. 当有更多元素的时候，取中间某段，如[...n-2, n-1, n, n+1, n+2, ...].
   到n时，要么时f(n-2) + nums[n]，要么是f(n-1) ====== f是指此前包含的钱
   又例如到n时，要么抢n和n+2的，要么就抢n+1的，如此计算下去
   
由3这种小情况可知，这样一定能抢到最大的数额，不浪费次数，抢的次数是“最多的”
而且也保证了一定不会相邻
突然有点理解为什么叫“动态”了，因为比较的过程不是一成不变的
下面给出代码 

```java
    public int rob(int nums[]){
        int preMax = 0;
        int curMax = 0;
        for(int x : nums){
            int temp = curMax;
            curMax = Math.max(curMax, preMax + x);
            preMax = temp;
        }
        return curMax;
    }
```


以输入: [1,2,3,1]为例
可以这样加点修饰：[0,  0,  1, 2, 3, 1]
分别对应         pre cur  x
一起迭代向前
手动跑完这个计算试试
1. 一开始如上初值,然后开始遍历数组，现在数组走到第一个元素1
2. 按照之前说的，要么是A + C，要么是B，现在这个就是x和pre的和与cur进行比较，因为它们是互不相邻的嘛
3. 比较下来，pre+x更大，所以现在cur就变成了1,pre依旧不变（它是指前一个）
4. 继续，x到了2的地方，现在又进行一轮比较了，是取f(n-2)+sum[n]，还是取f(n-1)?
5. 现在是2更大了，所以cur就变成了2，pre则指向了1，
6. 现在x指向了3，那么又来一次比较了，是3+1(x+pre)大呢还是2(cur)大呢？显然是3+1大，所以cur就变成了4了，pre则变成了2（总是x的前一个元素）
7. 然后x现在指向了1，是1+2(x+pre)大还是4(cur)大？这个元素不够大，所以不变，cur仍然是4
8. 循环结果，返回结果cur=4
9. 可知时间复杂度为O(n)，数组中的每个元素都跑了一遍,空间复杂度为O(1)，只用了常数的额外空间。

？？？？我感觉还是有点不大理解这个，以后回头看看说不定就懂得更多了。。。
